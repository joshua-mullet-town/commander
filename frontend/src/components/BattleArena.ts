import type { GameState, GamePiece } from '../types/game';

export interface BattleArenaOptions {
  playerPerspective?: 'A' | 'B' | 'spectator';
  showEnemyCommands?: boolean;
  enableAnimations?: boolean;
  onPieceClick?: (piece: { x: number; y: number; pieceId: number; player: 'A' | 'B' }) => void;
  onQueueMove?: (move: { pieceId: number; direction: 'up' | 'down' | 'left' | 'right'; distance: number }) => void;
}

export class BattleArena {
  private container: HTMLElement;
  private gameState: GameState | null = null;
  private playerPerspective: 'A' | 'B' | 'spectator';
  private showEnemyCommands: boolean;
  private enableAnimations: boolean;
  private onPieceClick?: BattleArenaOptions['onPieceClick'];
  private onQueueMove?: BattleArenaOptions['onQueueMove'];
  private dragState: { pieceId: number; player: 'A' | 'B'; startX: number; startY: number; startGridX: number; startGridY: number; lastGhostCell?: string; lastDirection?: 'up' | 'down' | 'left' | 'right'; lastDistance?: number } | null = null;
  private queuedMoves: Map<number, { direction: 'up' | 'down' | 'left' | 'right'; distance: number; player: 'A' | 'B' }> = new Map();
  private countdownInterval: number | null = null;
  private gameStartTime: number | null = null;
  private totalGameTime: number | null = null;

  constructor(containerId: string, options: BattleArenaOptions = {}) {
    const container = document.getElementById(containerId);
    if (!container) {
      throw new Error(`Container with id "${containerId}" not found`);
    }

    this.container = container;
    this.playerPerspective = options.playerPerspective || 'A';
    this.showEnemyCommands = options.showEnemyCommands !== false;
    this.enableAnimations = options.enableAnimations !== false;
    this.onPieceClick = options.onPieceClick;
    this.onQueueMove = options.onQueueMove;

    this.init();
  }

  private init(): void {
    this.createHTML();
  }

  private createHTML(): void {
    this.container.innerHTML = `
      <div class="bg-gradient-to-br from-purple-900 via-slate-900 to-cyan-900 rounded-3xl border-4 border-cyan-400 shadow-[0_0_40px_rgba(34,211,238,0.5)] p-8 text-white font-mono w-full mx-auto select-none relative overflow-hidden">
        <!-- Retro grid background effect -->
        <div class="absolute inset-0 opacity-10" style="background-image: linear-gradient(cyan 1px, transparent 1px), linear-gradient(90deg, cyan 1px, transparent 1px); background-size: 20px 20px;"></div>

        <div class="relative z-10">
          <!-- Header -->
          <div class="text-center mb-8">
            <h2 class="text-5xl font-black mb-3 tracking-wider" style="text-shadow: 0 0 20px rgba(236,72,153,0.8), 0 0 40px rgba(34,211,238,0.6); background: linear-gradient(90deg, #ec4899, #22d3ee, #a855f7); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">‚öîÔ∏è COMMANDER ‚öîÔ∏è</h2>
            <div class="bg-gradient-to-r from-pink-500/20 via-purple-500/20 to-cyan-500/20 border-2 border-pink-400 px-6 py-3 rounded-xl text-lg font-bold tracking-wide shadow-[0_0_15px_rgba(236,72,153,0.4)]" id="gameStatus" style="text-shadow: 0 0 10px rgba(255,255,255,0.5);">‚ö° BATTLE IN PROGRESS ‚ö°</div>
          </div>

          <!-- Round & Timer Info -->
          <div class="flex justify-between mb-6 px-6 py-4 bg-black/60 rounded-xl text-base font-bold border-2 border-purple-400 shadow-[0_0_20px_rgba(168,85,247,0.3)]" style="backdrop-filter: blur(10px);">
            <span id="currentRound" class="text-cyan-300" style="text-shadow: 0 0 10px rgba(34,211,238,0.8);">Round: 1</span>
            <span id="nextTick" class="text-pink-300" style="text-shadow: 0 0 10px rgba(236,72,153,0.8);">Next tick: 3s</span>
          </div>

          <!-- Battle Zone -->
          <div class="flex justify-center mb-8">
            <div class="flex flex-col gap-4">
              <!-- Player A Jail (Top-right aligned) -->
              <div class="self-end bg-gradient-to-br from-blue-900/60 to-blue-600/40 border-4 border-blue-400 rounded-2xl p-3 min-h-20 shadow-[0_0_25px_rgba(96,165,250,0.6)]" style="backdrop-filter: blur(5px); width: fit-content;">
                <div class="text-xs font-black mb-2 text-blue-200 text-center tracking-wider" style="text-shadow: 0 0 8px rgba(96,165,250,0.9);">üîí BLUE JAIL</div>
                <div id="jailA" class="flex flex-row gap-2 items-center text-xs"></div>
              </div>

              <!-- Battle Board -->
              <div class="relative">
                <div class="grid grid-cols-11 gap-1 bg-gradient-to-br from-slate-800 to-slate-950 p-6 rounded-2xl border-4 border-cyan-400 shadow-[0_0_30px_rgba(34,211,238,0.5)]" id="board" style="backdrop-filter: blur(10px);">
                  <!-- 11x11 grid generated by JavaScript -->
                </div>
                <!-- Animation overlay layer -->
                <div class="absolute inset-0 pointer-events-none" id="animationLayer"></div>
              </div>

              <!-- Player B Jail (Bottom-left) -->
              <div class="bg-gradient-to-br from-red-900/60 to-red-600/40 border-4 border-red-400 rounded-2xl p-3 min-h-20 shadow-[0_0_25px_rgba(248,113,113,0.6)]" style="backdrop-filter: blur(5px); width: fit-content;">
                <div class="text-xs font-black mb-2 text-red-200 text-center tracking-wider" style="text-shadow: 0 0 8px rgba(248,113,113,0.9);">üîí RED JAIL</div>
                <div id="jailB" class="flex flex-row gap-2 items-center text-xs"></div>
              </div>
            </div>
          </div>

          <!-- Command Queue -->
          <div class="grid grid-cols-2 gap-6">
            <div class="bg-gradient-to-br from-cyan-900/50 to-blue-900/50 rounded-xl p-4 min-h-24 border-2 border-cyan-400 shadow-[0_0_15px_rgba(34,211,238,0.3)]">
              <div class="font-black mb-3 text-sm text-cyan-300 tracking-wider" style="text-shadow: 0 0 10px rgba(34,211,238,0.6);">üìã YOUR COMMANDS</div>
              <div class="text-sm leading-relaxed text-cyan-100" id="yourQueue">No commands queued</div>
            </div>

            <div class="bg-gradient-to-br from-pink-900/50 to-purple-900/50 rounded-xl p-4 min-h-24 border-2 border-pink-400 shadow-[0_0_15px_rgba(236,72,153,0.3)]" id="enemyQueueSection">
              <div class="font-black mb-3 text-sm text-pink-300 tracking-wider" style="text-shadow: 0 0 10px rgba(236,72,153,0.6);">üëÅÔ∏è ENEMY ACTIVITY</div>
              <div class="text-sm leading-relaxed text-pink-100" id="enemyQueue">Enemy is planning...</div>
            </div>
          </div>
        </div>
      </div>
    `;

    this.initializeBoard();
  }

  private initializeBoard(): void {
    const board = this.container.querySelector('#board') as HTMLElement;
    if (!board) return;

    board.innerHTML = '';

    for (let y = 0; y < 11; y++) {
      for (let x = 0; x < 11; x++) {
        const cell = document.createElement('div');

        // Territory-based coloring
        // Rows 6-10 = Player A (Blue) territory
        // Row 5 = Neutral zone
        // Rows 0-4 = Player B (Red) territory
        let territoryColor = 'bg-slate-900/50'; // default
        if (y >= 6 && y <= 10) {
          // Player A territory (blue)
          territoryColor = 'bg-blue-950/30';
        } else if (y >= 0 && y <= 4) {
          // Player B territory (red)
          territoryColor = 'bg-red-950/30';
        } else {
          // Neutral zone (row 5)
          territoryColor = 'bg-purple-950/30';
        }

        cell.className = `w-8 h-8 ${territoryColor} border border-cyan-400/30 flex items-center justify-center relative cursor-pointer transition-all duration-200 hover:bg-cyan-500/20 hover:border-cyan-300 hover:shadow-[0_0_10px_rgba(34,211,238,0.4)]`;
        cell.id = `cell-${x}-${y}`;
        cell.dataset.x = x.toString();
        cell.dataset.y = y.toString();

        // Add click handler for piece interaction
        cell.addEventListener('click', () => {
          if (this.onPieceClick) {
            const piece = cell.querySelector('.piece') as HTMLElement;
            if (piece) {
              this.onPieceClick({
                x: parseInt(x.toString()),
                y: parseInt(y.toString()),
                pieceId: parseInt(piece.textContent || '0'),
                player: piece.classList.contains('piece-a') ? 'A' : 'B'
              });
            }
          }
        });

        board.appendChild(cell);
      }
    }
  }

  // Main update method - call this when game state changes
  updateGameState(gameState: GameState): void {
    const prevState = this.gameState;

    // Track game start time
    if (prevState?.gameStatus !== 'playing' && gameState.gameStatus === 'playing' && this.gameStartTime === null) {
      this.gameStartTime = Date.now();
    }

    // Calculate total game time when game finishes
    if (prevState?.gameStatus === 'playing' && gameState.gameStatus === 'finished' && this.totalGameTime === null) {
      if (this.gameStartTime !== null) {
        this.totalGameTime = (Date.now() - this.gameStartTime) / 1000; // Convert to seconds
      }
    }

    this.gameState = gameState;

    this.updateRoundInfo();
    this.updatePlayerStatus();
    this.updateBoard(prevState);
    this.updateCommandQueues();
    this.startCountdownUpdates();
  }

  private updateRoundInfo(): void {
    if (!this.gameState) return;

    const roundEl = this.container.querySelector('#currentRound') as HTMLElement;
    const statusEl = this.container.querySelector('#gameStatus') as HTMLElement;

    if (roundEl) roundEl.textContent = `Round: ${this.gameState.round}`;

    // Countdown is now calculated locally in updateCountdown()
    this.updateCountdown();

    if (statusEl) {
      // Update game status with better messaging
      switch (this.gameState.gameStatus) {
        case 'waiting':
          statusEl.textContent = 'Waiting for players...';
          break;
        case 'paused':
          statusEl.textContent = this.gameState.players.A && this.gameState.players.B ?
            'Both players ready! Game starting soon...' : 'Game paused - waiting for players';
          break;
        case 'playing':
          statusEl.textContent = 'üéÆ Battle in progress!';
          break;
        case 'finished':
          if (this.gameState.winner) {
            // Personalize message based on player perspective
            if (this.playerPerspective === 'spectator') {
              const winnerTeam = this.gameState.winner === 'A' ? 'Blue Team' : 'Red Team';
              const winnerEmoji = this.gameState.winner === 'A' ? 'üîµ' : 'üî¥';
              statusEl.textContent = `üéâ ${winnerEmoji} ${winnerTeam} WINS! üéâ`;
            } else if (this.gameState.winner === this.playerPerspective) {
              statusEl.textContent = 'üéâ üèÜ YOU WIN! üèÜ üéâ';
            } else {
              statusEl.textContent = 'üíî YOU LOSE! üíî';
            }
          } else {
            statusEl.textContent = 'Game finished!';
          }
          break;
        default:
          statusEl.textContent = 'Ready to battle';
      }
    }
  }

  private updateCountdown(): void {
    if (!this.gameState) return;

    const tickEl = this.container.querySelector('#nextTick') as HTMLElement;
    if (!tickEl) return;

    // Calculate countdown locally using lastRoundTime
    if (this.gameState.gameStatus === 'playing' && this.gameState.lastRoundTime) {
      const elapsed = Date.now() - this.gameState.lastRoundTime;
      const remaining = Math.max(0, 3000 - elapsed);
      const timeText = (remaining / 1000).toFixed(1);
      tickEl.textContent = `Next tick: ${timeText}s`;
    } else if (this.gameState.gameStatus === 'finished' && this.totalGameTime !== null) {
      // Show the total game time when finished
      tickEl.textContent = `Total time: ${this.totalGameTime.toFixed(1)}s`;
    } else {
      tickEl.textContent = 'Next tick: -';
    }
  }

  private startCountdownUpdates(): void {
    // Clear any existing interval
    if (this.countdownInterval !== null) {
      clearInterval(this.countdownInterval);
    }

    // Only start countdown updates if game is playing
    if (this.gameState?.gameStatus === 'playing') {
      this.countdownInterval = window.setInterval(() => {
        this.updateCountdown();
      }, 100);
    }
  }

  private updatePlayerStatus(): void {
    if (!this.gameState) return;

    const playerAEl = this.container.querySelector('#playerAStatus') as HTMLElement;
    const playerBEl = this.container.querySelector('#playerBStatus') as HTMLElement;

    if (playerAEl) {
      playerAEl.textContent = this.gameState.players.A ?
        `Connected (${this.gameState.players.A.type})` : 'Waiting';
    }

    if (playerBEl) {
      playerBEl.textContent = this.gameState.players.B ?
        `Connected (${this.gameState.players.B.type})` : 'Waiting';
    }

  }

  private updateBoard(prevState: GameState | null): void {
    if (!this.gameState) return;

    // Animate pieces that moved (before clearing board)
    if (this.enableAnimations && prevState) {
      this.animateMovingPieces(prevState, this.gameState);
    }

    // Clear board first
    this.clearBoard();

    // Place pieces (instant redraw)
    if (this.gameState.players.A) {
      this.gameState.players.A.pieces.forEach(piece => {
        if (piece.alive) {
          this.placePiece(piece, 'A', prevState);
        }
      });
    }

    if (this.gameState.players.B) {
      this.gameState.players.B.pieces.forEach(piece => {
        if (piece.alive) {
          this.placePiece(piece, 'B', prevState);
        }
      });
    }

    // Update jails
    this.updateJails();

    // Place rescue key if it exists
    this.placeRescueKey();

    // Place flags
    this.placeFlags();

    // Re-draw ghost previews for queued moves (that haven't executed yet)
    this.redrawQueuedGhosts(prevState);
  }

  private clearBoard(): void {
    const cells = this.container.querySelectorAll('.cell, [id^="cell-"]');
    cells.forEach(cell => {
      const cellElement = cell as HTMLElement;
      // Remove pieces, keys, and flags
      // Preserve ghost previews if dragging OR if there are queued moves
      if (this.dragState || this.queuedMoves.size > 0) {
        // Preserve ghost previews during drag or when moves are queued
        cellElement.querySelectorAll('.piece, .rescue-key, .flag').forEach(el => el.remove());
      } else {
        // Clear everything including ghosts when not dragging and no queued moves
        cellElement.querySelectorAll('.piece, .rescue-key, .flag, .ghost-preview').forEach(el => el.remove());
      }
    });
  }

  private placePiece(piece: GamePiece, player: 'A' | 'B', prevState: GameState | null): void {
    const cell = this.container.querySelector(`#cell-${piece.x}-${piece.y}`) as HTMLElement;
    if (!cell) return;

    const pieceEl = document.createElement('div');
    const isDraggable = player === this.playerPerspective;

    // Add glowing ring for YOUR pieces
    const yourPieceBorder = isDraggable ? 'ring-2 ring-amber-300 shadow-[0_0_12px_rgba(252,211,77,0.8)]' : '';

    pieceEl.className = `piece piece-${player.toLowerCase()} rounded-full w-full h-full flex items-center justify-center font-black transition-all duration-300 relative z-10 ${
      player === 'A'
        ? 'bg-gradient-to-br from-blue-400 to-blue-600 text-white border-2 border-blue-300 shadow-[0_0_15px_rgba(59,130,246,0.8)]'
        : 'bg-gradient-to-br from-red-400 to-red-600 text-white border-2 border-red-300 shadow-[0_0_15px_rgba(239,68,68,0.8)]'
    } ${isDraggable ? 'cursor-grab active:cursor-grabbing' : ''} ${yourPieceBorder}`;
    pieceEl.style.fontSize = 'clamp(0.25rem, 1.5vw, 0.6rem)'; // Responsive text size - matches ghost pieces
    pieceEl.textContent = piece.id.toString();
    pieceEl.dataset.pieceId = piece.id.toString();
    pieceEl.dataset.player = player;
    pieceEl.dataset.gridX = piece.x.toString();
    pieceEl.dataset.gridY = piece.y.toString();

    // Check if piece moved (for animations)
    if (this.enableAnimations && prevState) {
      const prevPlayer = prevState.players[player];
      if (prevPlayer) {
        const prevPiece = prevPlayer.pieces.find(p => p.id === piece.id);
        if (prevPiece && (prevPiece.x !== piece.x || prevPiece.y !== piece.y)) {
          // Piece moved - animate it
          pieceEl.classList.add('animate-piece-move');
          setTimeout(() => pieceEl.classList.remove('animate-piece-move'), 400);
        }
      }
    }

    // Add drag handlers only for player's own pieces
    if (isDraggable) {
      pieceEl.addEventListener('mousedown', (e) => this.handlePieceDragStart(e, piece, player));
    }

    cell.appendChild(pieceEl);
  }

  private updateCommandQueues(): void {
    if (!this.gameState) return;

    const yourQueueEl = this.container.querySelector('#yourQueue') as HTMLElement;
    const enemyQueueEl = this.container.querySelector('#enemyQueue') as HTMLElement;
    const enemySection = this.container.querySelector('#enemyQueueSection') as HTMLElement;

    // Show/hide enemy queue based on options
    if (enemySection) {
      if (this.showEnemyCommands) {
        enemySection.style.display = 'block';
      } else {
        enemySection.style.display = 'none';
        return;
      }
    }

    // Determine which player is "you" and which is "enemy"
    const yourPlayer = this.playerPerspective === 'spectator' ? 'A' : this.playerPerspective;
    const enemyPlayer = yourPlayer === 'A' ? 'B' : 'A';

    // Update your commands
    const yourCommands = this.getPlayerCommands(yourPlayer);
    if (yourQueueEl) {
      yourQueueEl.innerHTML = yourCommands.length > 0 ?
        yourCommands.map(cmd => `<div class="bg-white/10 px-2 py-1 rounded mb-1">${cmd}</div>`).join('') :
        'No commands queued';
    }

    // Update enemy commands (obfuscated)
    const enemyCommands = this.getObfuscatedEnemyCommands(enemyPlayer);
    if (enemyQueueEl) {
      enemyQueueEl.innerHTML = enemyCommands.length > 0 ?
        enemyCommands.map(cmd => `<div class="bg-orange-200/20 text-white/70 px-2 py-1 rounded mb-1">${cmd}</div>`).join('') :
        'Enemy is planning...';
    }
  }

  private getPlayerCommands(player: 'A' | 'B'): string[] {
    if (!this.gameState) return [];

    const commands: string[] = [];
    const commandQueue = this.gameState.commandQueue;

    Object.keys(commandQueue).forEach(round => {
      const roundCommands = commandQueue[round];
      const playerKey = `player${player}` as keyof typeof roundCommands;

      if (roundCommands[playerKey] && roundCommands[playerKey]!.length > 0) {
        const cmdList = roundCommands[playerKey]!.map(cmd =>
          `P${cmd.pieceId}‚Üí${cmd.direction}(${cmd.distance})`
        ).join(', ');
        commands.push(`Round ${round}: ${cmdList}`);
      }
    });

    return commands;
  }

  private getObfuscatedEnemyCommands(enemyPlayer: 'A' | 'B'): string[] {
    if (!this.gameState) return [];

    const commands: string[] = [];
    const commandQueue = this.gameState.commandQueue;

    Object.keys(commandQueue).forEach(round => {
      const roundCommands = commandQueue[round];
      const playerKey = `player${enemyPlayer}` as keyof typeof roundCommands;

      if (roundCommands[playerKey] && roundCommands[playerKey]!.length > 0) {
        const cmdCount = roundCommands[playerKey]!.length;
        // Show that enemy has commands but obfuscate details
        commands.push(`Round ${round}: ${cmdCount} command${cmdCount > 1 ? 's' : ''} planned`);
      }
    });

    return commands;
  }

  // Public API methods
  setPlayerPerspective(player: 'A' | 'B'): void {
    this.playerPerspective = player;
    this.updateCommandQueues();
  }

  toggleEnemyCommands(show: boolean): void {
    this.showEnemyCommands = show;
    this.updateCommandQueues();
  }

  highlightCell(x: number, y: number, className = 'highlight'): void {
    const cell = this.container.querySelector(`#cell-${x}-${y}`) as HTMLElement;
    if (cell) {
      cell.classList.add(className);
      setTimeout(() => cell.classList.remove(className), 1000);
    }
  }

  private handlePieceDragStart(e: MouseEvent, piece: GamePiece, player: 'A' | 'B'): void {
    e.preventDefault();

    this.dragState = {
      pieceId: piece.id,
      player,
      startX: e.clientX,
      startY: e.clientY,
      startGridX: piece.x,
      startGridY: piece.y
    };

    // Add global mouse move and up handlers
    const handleMouseMove = (e: MouseEvent) => this.handlePieceDragMove(e);
    const handleMouseUp = (e: MouseEvent) => {
      this.handlePieceDragEnd(e);
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('mouseup', handleMouseUp);
    };

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  }

  private handlePieceDragMove(e: MouseEvent): void {
    if (!this.dragState) return;

    // Temporarily hide all pieces to detect the cell underneath
    const pieces = this.container.querySelectorAll('.piece');
    pieces.forEach(p => (p as HTMLElement).style.pointerEvents = 'none');

    // Use elementFromPoint to detect which cell is under the cursor
    const element = document.elementFromPoint(e.clientX, e.clientY);
    const cell = element?.closest('[id^="cell-"]') as HTMLElement;

    // Restore pointer events
    pieces.forEach(p => (p as HTMLElement).style.pointerEvents = '');

    if (cell && cell.id.startsWith('cell-')) {
      // Extract grid coordinates from cell ID (format: cell-x-y)
      const parts = cell.id.split('-');
      const hoverX = parseInt(parts[1]);
      const hoverY = parseInt(parts[2]);

      // Calculate deltas from start position
      const gridDeltaX = hoverX - this.dragState.startGridX;
      const gridDeltaY = hoverY - this.dragState.startGridY;

      // Show visual feedback (arrow overlay)
      this.showDragArrow(this.dragState.startGridX, this.dragState.startGridY, gridDeltaX, gridDeltaY);

      // Determine and store direction/distance for use on drop
      let direction: 'up' | 'down' | 'left' | 'right' | null = null;
      let distance = 0;

      if (Math.abs(gridDeltaX) > Math.abs(gridDeltaY)) {
        // Horizontal movement
        if (gridDeltaX > 0) {
          direction = 'right';
          distance = gridDeltaX;
        } else if (gridDeltaX < 0) {
          direction = 'left';
          distance = Math.abs(gridDeltaX);
        }
      } else {
        // Vertical movement
        if (gridDeltaY > 0) {
          direction = 'down';
          distance = gridDeltaY;
        } else if (gridDeltaY < 0) {
          direction = 'up';
          distance = Math.abs(gridDeltaY);
        }
      }

      // Store for use on drop
      this.dragState.lastDirection = direction || undefined;
      this.dragState.lastDistance = distance > 0 ? distance : undefined;

      // Show ghost at ACTUAL destination based on direction/distance, not hover position
      if (direction && distance > 0) {
        // Calculate actual destination based on direction and distance
        let destX = this.dragState.startGridX;
        let destY = this.dragState.startGridY;

        switch (direction) {
          case 'up':
            destY = Math.max(0, this.dragState.startGridY - distance);
            break;
          case 'down':
            destY = Math.min(10, this.dragState.startGridY + distance);
            break;
          case 'left':
            destX = Math.max(0, this.dragState.startGridX - distance);
            break;
          case 'right':
            destX = Math.min(10, this.dragState.startGridX + distance);
            break;
        }

        const cellKey = `${destX}-${destY}`;
        if (this.dragState.lastGhostCell !== cellKey) {
          // Clear ALL ghost previews before creating new one
          this.container.querySelectorAll('.ghost-preview').forEach(el => el.remove());
          this.showGhostInCell(destX, destY, this.dragState.pieceId, this.dragState.player);
          this.dragState.lastGhostCell = cellKey;
        }
      } else {
        // Invalid move (no direction), clear ghosts
        this.container.querySelectorAll('.ghost-preview').forEach(el => el.remove());
        this.dragState.lastGhostCell = undefined;
      }
    }
  }

  private handlePieceDragEnd(e: MouseEvent): void {
    if (!this.dragState) return;

    // Clear drag arrow
    this.clearDragArrow();

    // Use the stored direction/distance from last drag move
    const direction = this.dragState.lastDirection;
    const distance = this.dragState.lastDistance;

    // Queue the move if valid
    if (direction && distance && distance > 0 && this.onQueueMove) {
      this.onQueueMove({
        pieceId: this.dragState.pieceId,
        direction,
        distance
      });

      // Store queued move so ghost persists
      this.queuedMoves.set(this.dragState.pieceId, {
        direction,
        distance,
        player: this.dragState.player
      });

      // Ghost preview will persist because of queuedMoves
    }

    this.dragState = null;
  }

  private showDragArrow(startX: number, startY: number, deltaX: number, deltaY: number): void {
    // Clear previous arrow
    this.clearDragArrow();

    if (deltaX === 0 && deltaY === 0) return;

    // Create arrow overlay - huge background indicator
    const arrow = document.createElement('div');
    arrow.id = 'drag-arrow';
    arrow.className = 'absolute pointer-events-none z-0 inset-0 flex items-center justify-center';

    // Determine primary direction
    let direction = '';
    let length = 0;
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      direction = deltaX > 0 ? '‚Üí' : '‚Üê';
      length = Math.abs(deltaX);
    } else {
      direction = deltaY > 0 ? '‚Üì' : '‚Üë';
      length = Math.abs(deltaY);
    }

    arrow.innerHTML = `
      <div class="text-cyan-300/10 font-black whitespace-nowrap select-none" style="font-size: clamp(4rem, 20vw, 12rem); text-shadow: 0 0 40px rgba(34,211,238,0.15);">
        ${direction} ${length}
      </div>
    `;

    this.container.querySelector('#board')?.appendChild(arrow);
  }

  private clearDragArrow(): void {
    const arrow = this.container.querySelector('#drag-arrow');
    if (arrow) {
      arrow.remove();
    }
  }

  private animateMovingPieces(prevState: GameState, newState: GameState): void {
    const animationLayer = this.container.querySelector('#animationLayer');
    if (!animationLayer) return;

    // Check Player A pieces
    if (prevState.players.A && newState.players.A) {
      prevState.players.A.pieces.forEach(prevPiece => {
        const newPiece = newState.players.A!.pieces.find(p => p.id === prevPiece.id);
        if (!newPiece) return;

        // Piece moved and is still alive
        if (prevPiece.alive && newPiece.alive && (prevPiece.x !== newPiece.x || prevPiece.y !== newPiece.y)) {
          this.createGhostAnimation(prevPiece, newPiece, 'A', animationLayer, false);
        }
        // Piece was alive, moved, and got jailed
        else if (prevPiece.alive && !newPiece.alive && (prevPiece.x !== newPiece.x || prevPiece.y !== newPiece.y)) {
          this.createGhostAnimation(prevPiece, newPiece, 'A', animationLayer, true);
        }
      });
    }

    // Check Player B pieces
    if (prevState.players.B && newState.players.B) {
      prevState.players.B.pieces.forEach(prevPiece => {
        const newPiece = newState.players.B!.pieces.find(p => p.id === prevPiece.id);
        if (!newPiece) return;

        // Piece moved and is still alive
        if (prevPiece.alive && newPiece.alive && (prevPiece.x !== newPiece.x || prevPiece.y !== newPiece.y)) {
          this.createGhostAnimation(prevPiece, newPiece, 'B', animationLayer, false);
        }
        // Piece was alive, moved, and got jailed
        else if (prevPiece.alive && !newPiece.alive && (prevPiece.x !== newPiece.x || prevPiece.y !== newPiece.y)) {
          this.createGhostAnimation(prevPiece, newPiece, 'B', animationLayer, true);
        }
      });
    }
  }

  private createGhostAnimation(fromPiece: GamePiece, toPiece: GamePiece, player: 'A' | 'B', animationLayer: Element, gotJailed: boolean): void {
    // Get actual cell elements to calculate exact positions
    const fromCell = this.container.querySelector(`#cell-${fromPiece.x}-${fromPiece.y}`) as HTMLElement;
    const toCell = this.container.querySelector(`#cell-${toPiece.x}-${toPiece.y}`) as HTMLElement;

    if (!fromCell || !toCell) return;

    const board = this.container.querySelector('#board') as HTMLElement;
    if (!board) return;

    // Get board position as reference
    const boardRect = board.getBoundingClientRect();

    // Get cell positions relative to board
    const fromCellRect = fromCell.getBoundingClientRect();
    const toCellRect = toCell.getBoundingClientRect();
    const cellWidth = toCellRect.width;
    const pieceSize = cellWidth * 0.75; // Piece is 75% of cell width
    const halfPiece = pieceSize / 2;

    // Calculate center positions relative to board
    const fromX = fromCellRect.left - boardRect.left + fromCellRect.width / 2 - halfPiece;
    const fromY = fromCellRect.top - boardRect.top + fromCellRect.height / 2 - halfPiece;
    let toX = toCellRect.left - boardRect.left + toCellRect.width / 2 - halfPiece;
    let toY = toCellRect.top - boardRect.top + toCellRect.height / 2 - halfPiece;

    // If collision/jail, stop one cell width before target, then add 7px back
    if (gotJailed) {
      const cellWidth = toCellRect.width;
      const deltaX = toX - fromX;
      const deltaY = toY - fromY;
      const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

      // Stop at: full distance - one cell width + 7px
      const stopDistance = distance - cellWidth + 7;
      const ratio = stopDistance / distance;

      toX = fromX + (deltaX * ratio);
      toY = fromY + (deltaY * ratio);
    }

    // Create ghost piece - size it based on cell size for responsiveness
    const ghost = document.createElement('div');
    ghost.className = `absolute rounded-full flex items-center justify-center font-black z-50 ${
      player === 'A'
        ? 'bg-gradient-to-br from-blue-400 to-blue-600 text-white border-2 border-blue-300 shadow-[0_0_15px_rgba(59,130,246,0.8)]'
        : 'bg-gradient-to-br from-red-400 to-red-600 text-white border-2 border-red-300 shadow-[0_0_15px_rgba(239,68,68,0.8)]'
    }`;
    ghost.style.width = `${pieceSize}px`;
    ghost.style.height = `${pieceSize}px`;
    ghost.style.fontSize = 'clamp(0.35rem, 2.5vw, 0.875rem)';
    ghost.textContent = fromPiece.id.toString();
    ghost.style.left = `${fromX}px`;
    ghost.style.top = `${fromY}px`;
    ghost.style.transition = 'all 0.4s ease-out';

    animationLayer.appendChild(ghost);

    // Trigger movement animation on next frame
    requestAnimationFrame(() => {
      ghost.style.left = `${toX}px`;
      ghost.style.top = `${toY}px`;
    });

    if (gotJailed) {
      // After moving to collision point, pause briefly, then shake and fade out
      setTimeout(() => {
        // Add shake animation
        ghost.style.animation = 'shake 0.3s ease-in-out, fadeOut 0.3s ease-in-out';
        ghost.style.animationDelay = '0s, 0.15s';
      }, 600); // Increased from 400ms to 600ms for longer pause

      // Remove ghost after pause + shake + fade
      setTimeout(() => {
        ghost.remove();
      }, 1300); // Increased from 1100ms to 1300ms
    } else {
      // Normal movement - remove after animation
      setTimeout(() => {
        ghost.remove();
      }, 400);
    }
  }

  private updateJails(): void {
    if (!this.gameState) return;

    // Update Player A jail
    const jailA = this.container.querySelector('#jailA') as HTMLElement;
    if (jailA && this.gameState.players.A) {
      jailA.innerHTML = '';
      this.gameState.players.A.jailedPieces?.forEach(pieceId => {
        const pieceEl = document.createElement('div');
        pieceEl.className = 'bg-blue-500 text-white rounded-full w-5 h-5 flex items-center justify-center font-bold text-xs';
        pieceEl.textContent = pieceId.toString();
        jailA.appendChild(pieceEl);
      });
    }

    // Update Player B jail
    const jailB = this.container.querySelector('#jailB') as HTMLElement;
    if (jailB && this.gameState.players.B) {
      jailB.innerHTML = '';
      this.gameState.players.B.jailedPieces?.forEach(pieceId => {
        const pieceEl = document.createElement('div');
        pieceEl.className = 'bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center font-bold text-xs';
        pieceEl.textContent = pieceId.toString();
        jailB.appendChild(pieceEl);
      });
    }
  }

  private placeRescueKey(): void {
    if (!this.gameState || !this.gameState.rescueKeys) return;

    // Place Blue team's key (Player A)
    if (this.gameState.rescueKeys.A) {
      const keyA = this.gameState.rescueKeys.A;
      const cellA = this.container.querySelector(`#cell-${keyA.x}-${keyA.y}`) as HTMLElement;
      if (cellA) {
        const keyEl = document.createElement('div');
        keyEl.className = 'rescue-key rescue-key-a absolute inset-0 flex items-center justify-center z-5';
        keyEl.style.fontSize = 'clamp(1rem, 4vw, 1.5rem)';
        keyEl.style.filter = 'hue-rotate(200deg) saturate(1.5)'; // Blue tint
        keyEl.textContent = 'üîë';
        keyEl.title = 'Blue Team Rescue Key - Land here to free jailed teammates!';
        cellA.appendChild(keyEl);
      }
    }

    // Place Red team's key (Player B)
    if (this.gameState.rescueKeys.B) {
      const keyB = this.gameState.rescueKeys.B;
      const cellB = this.container.querySelector(`#cell-${keyB.x}-${keyB.y}`) as HTMLElement;
      if (cellB) {
        const keyEl = document.createElement('div');
        keyEl.className = 'rescue-key rescue-key-b absolute inset-0 flex items-center justify-center z-5';
        keyEl.style.fontSize = 'clamp(1rem, 4vw, 1.5rem)';
        keyEl.style.filter = 'hue-rotate(0deg) saturate(1.5)'; // Red/orange tint
        keyEl.textContent = 'üîë';
        keyEl.title = 'Red Team Rescue Key - Land here to free jailed teammates!';
        cellB.appendChild(keyEl);
      }
    }
  }

  private placeFlags(): void {
    if (!this.gameState || !this.gameState.flags) return;

    // Place Blue flag (Player A's flag)
    const flagA = this.gameState.flags.A;
    if (flagA) {
      const cellA = this.container.querySelector(`#cell-${flagA.x}-${flagA.y}`) as HTMLElement;
      if (cellA) {
        const flagEl = document.createElement('div');
        // If flag is carried, show it on top of piece with transparency (z-20 is above pieces which are z-10)
        // If flag is not carried, show it normally (z-5 is below pieces)
        const isCarried = flagA.carriedBy !== null;
        flagEl.className = `flag flag-a absolute inset-0 flex items-center justify-center ${isCarried ? 'z-20' : 'z-5'}`;
        flagEl.style.fontSize = 'clamp(1.2rem, 5vw, 2rem)';
        flagEl.textContent = 'üö©';
        flagEl.style.filter = 'hue-rotate(200deg) saturate(1.5)'; // Blue tint
        flagEl.style.opacity = isCarried ? '0.5' : '1'; // 50% opacity when carried
        flagEl.style.pointerEvents = 'none'; // Allow clicks to pass through to piece underneath
        flagEl.title = flagA.carriedBy ? `Blue flag carried by ${flagA.carriedBy.player} Piece ${flagA.carriedBy.pieceId}` : 'Blue Flag - Capture and bring to your territory!';
        cellA.appendChild(flagEl);
      }
    }

    // Place Red flag (Player B's flag)
    const flagB = this.gameState.flags.B;
    if (flagB) {
      const cellB = this.container.querySelector(`#cell-${flagB.x}-${flagB.y}`) as HTMLElement;
      if (cellB) {
        const flagEl = document.createElement('div');
        // If flag is carried, show it on top of piece with transparency (z-20 is above pieces which are z-10)
        // If flag is not carried, show it normally (z-5 is below pieces)
        const isCarried = flagB.carriedBy !== null;
        flagEl.className = `flag flag-b absolute inset-0 flex items-center justify-center ${isCarried ? 'z-20' : 'z-5'}`;
        flagEl.style.fontSize = 'clamp(1.2rem, 5vw, 2rem)';
        flagEl.textContent = 'üö©';
        flagEl.style.filter = 'hue-rotate(0deg) saturate(1.5)'; // Red tint
        flagEl.style.opacity = isCarried ? '0.5' : '1'; // 50% opacity when carried
        flagEl.style.pointerEvents = 'none'; // Allow clicks to pass through to piece underneath
        flagEl.title = flagB.carriedBy ? `Red flag carried by ${flagB.carriedBy.player} Piece ${flagB.carriedBy.pieceId}` : 'Red Flag - Capture and bring to your territory!';
        cellB.appendChild(flagEl);
      }
    }
  }

  private showGhostInCell(x: number, y: number, pieceId: number, player: 'A' | 'B'): void {
    const cell = this.container.querySelector(`#cell-${x}-${y}`) as HTMLElement;
    if (!cell) return;

    // Check if a ghost for this piece already exists in this cell
    const existingGhost = cell.querySelector(`.ghost-preview[data-piece-id="${pieceId}"]`);
    if (existingGhost) {
      // Ghost already exists for this piece - don't redraw to prevent flashing
      return;
    }

    // Remove only ghosts for OTHER pieces in this cell (shouldn't happen, but just in case)
    cell.querySelectorAll(`.ghost-preview:not([data-piece-id="${pieceId}"])`).forEach(el => el.remove());

    const ghost = document.createElement('div');
    ghost.className = 'ghost-preview absolute inset-0 m-auto rounded-full flex items-center justify-center font-black z-30 border-2 border-white/70 text-white/80';
    ghost.setAttribute('data-piece-id', pieceId.toString());
    ghost.style.width = '100%';
    ghost.style.height = '100%';
    ghost.style.fontSize = 'clamp(0.25rem, 1.5vw, 0.6rem)';
    ghost.style.pointerEvents = 'none';
    ghost.style.background = 'transparent';
    ghost.style.boxShadow = '0 0 8px rgba(255, 255, 255, 0.3)';
    ghost.textContent = pieceId.toString();

    cell.appendChild(ghost);
  }

  private redrawQueuedGhosts(prevState: GameState | null): void {
    if (!this.gameState) return;

    // For each queued move, check if the piece has moved yet
    this.queuedMoves.forEach((move, pieceId) => {
      const playerData = this.gameState!.players[move.player];
      if (!playerData) {
        this.queuedMoves.delete(pieceId);
        return;
      }

      const piece = playerData.pieces.find(p => p.id === pieceId);
      if (!piece || !piece.alive) {
        this.queuedMoves.delete(pieceId);
        return;
      }

      // Calculate expected destination
      let destX = piece.x;
      let destY = piece.y;

      switch (move.direction) {
        case 'up':
          destY = Math.max(0, piece.y - move.distance);
          break;
        case 'down':
          destY = Math.min(10, piece.y + move.distance);
          break;
        case 'left':
          destX = Math.max(0, piece.x - move.distance);
          break;
        case 'right':
          destX = Math.min(10, piece.x + move.distance);
          break;
      }

      // Check if piece has already moved (by comparing with prev state)
      if (prevState) {
        const prevPlayerData = prevState.players[move.player];
        const prevPiece = prevPlayerData?.pieces.find(p => p.id === pieceId);

        if (prevPiece && (prevPiece.x !== piece.x || prevPiece.y !== piece.y)) {
          // Piece has moved - remove queued move and its ghost
          this.queuedMoves.delete(pieceId);
          // Remove the ghost from DOM
          const ghost = this.container.querySelector(`.ghost-preview[data-piece-id="${pieceId}"]`);
          if (ghost) ghost.remove();
          return;
        }
      }

      // Re-draw ghost at destination
      this.showGhostInCell(destX, destY, pieceId, move.player);
    });
  }

  private showGhostPreview(pieceId: number, player: 'A' | 'B', direction: 'up' | 'down' | 'left' | 'right', distance: number): void {
    if (!this.gameState) return;

    // Clear any existing ghost previews
    this.container.querySelectorAll('.ghost-preview').forEach(el => el.remove());

    // Find the piece's current position
    const playerData = this.gameState.players[player];
    if (!playerData) return;

    const piece = playerData.pieces.find(p => p.id === pieceId);
    if (!piece || !piece.alive) return;

    // Calculate destination
    let destX = piece.x;
    let destY = piece.y;

    switch (direction) {
      case 'up':
        destY = Math.max(0, piece.y - distance);
        break;
      case 'down':
        destY = Math.min(10, piece.y + distance);
        break;
      case 'left':
        destX = Math.max(0, piece.x - distance);
        break;
      case 'right':
        destX = Math.min(10, piece.x + distance);
        break;
    }

    // Place ghost at destination
    const destCell = this.container.querySelector(`#cell-${destX}-${destY}`) as HTMLElement;
    if (!destCell) return;

    const ghost = document.createElement('div');
    ghost.className = `ghost-preview absolute inset-0 rounded-full flex items-center justify-center font-black transition-all duration-300 z-20 opacity-50 animate-pulse border-4 ${
      player === 'A'
        ? 'bg-blue-500/60 text-white border-blue-300 shadow-[0_0_20px_rgba(59,130,246,0.6)]'
        : 'bg-red-500/60 text-white border-red-300 shadow-[0_0_20px_rgba(239,68,68,0.6)]'
    }`;
    ghost.style.fontSize = 'clamp(0.35rem, 2.5vw, 0.875rem)'; // Match piece sizing
    ghost.style.pointerEvents = 'none';
    ghost.textContent = pieceId.toString();
    ghost.title = `Queued move: ${direction} ${distance}`;

    destCell.appendChild(ghost);
  }
}